

 - Traffic directions
    - Traffic originating from the localhost to the remote-host
    - Return traffic from that remote-host back to the localhost
    - Traffic originating from the remote-host to the localhost
    - Return traffic from the localhost back to the remote-host
 - Host based filtering
    - Windows or Linux
       - What can Windows use
       - What can Linux use
       - Netfilter framework
          - Packet filtering
          - statless/stateful Firewalls
          - network address and port translation (NAT and PAT)
          - other packet manipulation
          - Netfilterr Hooks
             - NF_IP_PRE_ROUTING → PREROUTING
             - NF_IP_LOCAL_IN → INPUT
             - NF_IP_FORWARD → FORWARD
             - NF_IP_LOCAL_OUT → OUTPUT
             - NF_IP_POST_ROUTING → POSTROUTING
          - Netfilter paradigm
             - tables - contains chains
             - chains - contain rules
             - rules - dictate what to match and what actions to perform on packets when packets match a rule
    - Configuring IPtables
       - Seperate applications
          - Netfilter created several (seperate applications to filter on different layer 2 and layer 3+ protocols)
          - iptables - IPv4 packet administration
          - ip6tables - IPv6 packet administration
          - ebtables - Ethernet bridge frame table administration
          - arptables - arp packet administration
       - Each application has several tables and chains
          - filter - default table. Provide packet filtering
             - INPUT,FORWARD, and OUTPUT
          - nat - used to translate private <-> public address and ports
             - PREROUTING,POSTROUTING, and OUTPUT
          - mangle - provides special packet alteration. Can modify various fields header fields
             - All Chains: PREROUTING,POSTROUTING,INPUT,FORWARD and OUTPUT
          - raw - used to configure exemptions from connection tracking
             - PREROUTING and OUTPUT
          - security - used for mandatory access control networking rules
             - INPUT,FORWARD and OUTPUT
       - Common IPtables options
          - A - append a rule (bottom)
          - I - insert a rule (top)
          - D - delete a rule
          - L - list rules by chains
          - P - changes the default policy for a chain
          - p list a protocol
          - sport/dport - specifies a port
          - d - desination address
          - s - source address
          - j - jump to target action
          - n - displays port number vice protocol
          - t - specifies a table, default is filter
          - linenumbers - prints the rule number in the output
          - F - flushes the table
          - change default policy
             - iptables -t [table] -P [chain] [action]
          - List rules with rule numbers
             - iptables -t [table] -L --line-numbers
          - Lists rules as commands interpreted by the system
             - iptables -t [table] -S
          - Inserts rule before the rule number
             - iptables -t [table] -I [chain] [rule num] [rules] -j [action]
          - Deletes rule at number
             - iptables -t [table] -D [chain] [rule num]
    - Configuring NFTables
       - NFTable families
          - ip - IPv4 packtes
          - ip6 IPv6 packets
          - inet - IPv4 and IPv6 packets
          - bridge - processing traffic/packets traversing bridges
          - netdev - allows for users classifications of packsets - nftables passes up to the netowrking stack
       - Introduces chain-types
          - There are three chain types
             - filter - to filter packets - can be used with arp,bridge,ip,ip6, and inet families
             - route - to rereoute packets - can be used with ip and ip6 families only
             - nat - used for Network Address Translation - used with ip and ip6 table famailies only
       - Creation of hooks
          - PREROUTING
          - POSTROUTING
          - INPUT
          - OUTPUT
          - FORWARD
          - INGRESS - used with NETDEV family only
       - NFTables enhancements
          - one table command to replace multiple
          - simpler, cleaner syntax
          - less code duplication
          - simultaneous configuration of IPv4 and IPv6
       - Create the Table
          - nft add table [family] [table]
             - [family] = ip, ip6, inet, arp, bridge and netdev.
             - [table] = user provided name for the table.
       - Create the Base Chain
          - nft add chain [family] [table] [chain] { type [type] hook [hook] priority [priority] \; policy [policy] \;}
             - [chain] = User defined name for the chain.
             - [type] =  can be filter, route or nat.
             - [hook] = prerouting, ingress, input, forward, output or postrouting
             - [priority] = user provided integer. Lower number = higher
                            priority. default = 0. Use "--" before negative numbers.
             - ; [policy] ; = set policy for the chain. Can be accept (default) or drop.
              Use "\" to escape the ";" in bash
        - Create a rule in the Chain
           - nft add rule [family] [table] [chain] [matches (matches)] [statement]
              - [matches] = typically protocol headers(i.e. ip, ip6, tcp, udp, icmp, ether, etc)
              - (matches) = these are specific to the [matches] field.
              - [statement] = action performed when packet is matched. Some examples are: log, accept, drop, reject,
                              counter, nat (dnat, snat, masquerade)
        - Modify nftables
           - nft {list | flush} ruleset
           - nft {delete | list | flush } table [family] [table]
           - nft {delete | list | flush } chain [family] [table] [chain]
           - Adds after position
              - nft add rule [family] [table] [chain] [position <position>] [matches (matches)] [statement]
           - Inserts before position
              - nft insert rule [family] [table] [chain] [position <position>] [matches (matches)] [statement]
           - Replaces rule at handle
              - nft replace rule [family] [table] [chain] [handle <handle>] [matches (matches)] [statement]
           - Deletes rule at handle
              - nft delete rule [family] [table] [chain] [handle <handle>]
     - NFT/IP table demo
        - IPtables
           - sudo iptables -L (chains)
           - sudo iptables -L -t nat (nat chains)
           - sudo iptables -L -t mangle (mangle chains)
           - sudo iptables -F (flushes default)
           - sudo iptables -F -t nat (flushes nat)
           - sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT (allows connections from anyone via ssh)
           - sudo iptables -A INPUT -p tcp --sport 22 -j ACCEPT
           - sudo iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
           - sudo iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
           - sudo iptables -P INPUT DROP (changes the default policy)
           - sudo iptables -L --line (display rules with line number)
           - sudo iptables -D OUTPUT 3 (delete a rule by chain and line number)
           - sudo iptables -I OUTPUT -d 172.16.82.106 -j REJECT (explicitly deny to 172.16.82.106)
           - sudo iptables -I INPUT -s 172.16.82.106 -j REJECT (explicitly deny from 172.16.82.106)
           - sudo iptables -A INPUT -s 172.16.82.112 -j ACCEPT (explicitly allow from 172.16.82.112)
           - sudo iptables -A OUTPUT -d 172.16.82.112 -j ACCEPT (explicitly allow to 172.16.82.112)
           - sudo iptables -L --line -v (provides data regarding the rule)
           - *** sudo iptables -A OUTPUT -p tcp -m multiport --ports 22,6010,6011,6012 -m state --state NEW,ESTABLISHED -j ACCEPT
           - for CHAIN in INPUT OUTPUT FORWARD;do sudo iptables -P $CHAIN ACCEPT; done (change all policies at the same time)
           - sudo iptables-save > ipc.conf
           - sudo iptables-restore < ipc.conf
        - NFTables
           - sudo nft add table ip CCTC (Creates the table)
           - sudo nft list ruleset (lists the rules)
           - sudo nft flush table ip CCTC (flushes the CCTC table)
           - sudo nft delete table ip CCTC (deletes a table)
           - sudo nft add chain ip CCTC input {type filter hook input priority 0 \; policy accept \;}
             (set a filter to accept input at a highest priority with an accept policy)
           - sudo nft add chain ip CCTC output {type filter hook output priority 0 \; policy accept \;}
           - sudo nft add rule ip CCTC input tcp sport 22 accept (adds a rule to acccept all tcp ssh traffic)
           - sudo nft add rule ip CCTC input tcp dport 22 accept
           - sudo nft add rule ip CCTC output tcp sport 22 accept
           - sudo nft add rule ip CCTC output tcp dport 22 accept
           - sudo nft list chain ip CCTC input -ann (View rules by chain)
           - sudo nft add chain ip CCTC input {type filter hook input priority 0 \; policy drop \;} (sets default to drop)
           - sudo nft add chain ip CCTC output {type filter hook output priority 0 \; policy drop \;} (sets default to drop)
           - sudo nft add rule ip CCTC input ip saddr 172.16.82.112 drop (adding a source IP)
           - sudo nft add rule ip CCTC output ip daddr 172.16.82.112 drop (adding a destination ip)
           - sudo nft add rule ip CCTC input ip saddr 10.10.0.40 accept (adding a source IP)
           - sudo nft add rule ip CCTC output ip daddr 10.10.0.40 accept (adding a destination ip)
           - sudo nft delete rule ip CCTC input handle 15 (deleting a rule by handle)
           - sudo nft list ruleset > nftables.conf (saves the rules)
           - sudo nft -f nftables.conf (reload the saved rules)
           - sudo nft flush table CCTC (flush the rules)
           - 
           - 
           
 - Intrusion Detection and Prevention Systems
    - Placement
       - In line
       - or not
    - Recognition methods
       - Signature
       - Heuristic aka Behavioral
    - Common Intrusion Defense Systems
       - OSSEC
       - Snort
       - Suricata
       - Bro Network Security Monitor
       - Open WIPS NG
       - Samhain
       - Security Onion (Linux OS)
    - Snort IDS/IPS Rule - Header
       - [action] [protocol] [s.ip] [s.port] [direction] [d.ip] [d.port] ( match conditions ;)
       - Action - such as alert,log,pass,drop,reject
       - Protocol - Includes TCP,UDP,ICMP, and others
       - Source IP address - single address, CIDR notation, range or any
       - Source Port - one,multiple,any,or range of ports
       - Direction - either inbound or in and outbound
       - Destination IP address - options mirror source IP
       - Destination port - options mirror source port
    - SNORT IDS/IPS general rule options
       - msg - specifices the human-readable alert message
       - reference - links to external source of the rule
       - sid - used to uniqly identify snort rules
       - rev - uniquely identify revisions of snort rules
       - Classtype - used to describe what successful attack would do
       - Priority - Level of concern(1 - really bad, 2- badish, 3- informational)
       - metadata - allows a rule writer to embed additional information about the rule
    - Payload detection options
       - content - looks for a string of text.
       - |binary data| - to look for a string of binary HEX
       - nocase - modified content, makes it case insensitive
       - depth - specify how many bytes into a packet Snort should search for the specified pattern
       - distance - how far into a packet Snort should ignore before starting to search for the specified pattern 
                    relative to the end of the previous pattern match
       - within - modifier that makes sure that at most N bytes are between pattern matches using the content keyword
       - offset - skips a certain number of bytes before searching (i.e. offset: 12)
    - Non-payload detection options
       - Flow - direction (to/from client and server) and state of connection (established, stateless, stream/no stream)
       - ttl - The ttl keyword is used to check the IP time-to-live value.
       - tos - The tos keyword is used to check the IP TOS field for a specific value.
       - ipopts - The ipopts keyword is used to check if a specific IP option is present
       - seq - check for a specific TCP sequence number
       - ack - check for a specific TCP acknowledge number.
       - flags - The flags keyword is used to check if specific TCP flag bits are present.
       - itype - The itype keyword is used to check for a specific ICMP type value.
       - icode - The icode keyword is used to check for a specific ICMP code value.
    -  Post detection options
       - logto - The logto keyword tells Snort to log all packets that trigger this rule to a special output log file.
       - session - The session keyword is built to extract user data from TCP Sessions.
       - react - This keyword implements an ability for users to react to traffic that matches a Snort rule by closing connection and sending a notice.
       - tag - The tag keyword allow rules to log more than just the single packet that triggered the rule.
       - activates - This keyword allows the rule writer to specify a rule to add when a specific network event occurs.
       - activated_by - This keyword allows the rule writer to dynamically enable a rule when a specific activate rule is triggered.
       - count - Allows the rule writer to specify how many packets to leave the rule enabled for after it is activated.
    - Thresholding and suppression options
       - type [limit | threshold | both]
       - limit alerts on the 1st event during defined period then ignores the rest.
       - Threshold alerts every [x] times during defined period.
       - Both alerts once per time internal after seeing [x] amount of occurrences of event. It then ignores all other events during period.
       - track [by_src | by_dst] - rate is tracked either by source IP address, or destination IP address
       - count [#] - number of rule matching in [s] seconds that will cause event_filter limit to be exceeded
       - seconds [seconds] - time period over which count is accrued. [s] must be nonzero value
    - SNORT examples
       - Look for anonymous ftp traffic:
          - alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; sid:2121; )
       - This will cause the pattern matcher to start looking at byte 6 in the payload)
          - alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; offset:5; sid:2121; )
       - This will search the first 14 bytes of the packet looking for the word “anonymous”.
          - alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; depth:14; sid:2121; )
       - Deactivates the case sensitivity of a text search.
          - alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; nocase; sid:2121; )
    - Rule header
       - ICMP ping sweep
          - alert icmp any any -> 10.1.0.2 any (msg: "NMAP ping sweep Scan"; dsize:0; sid:10000004; rev: 1; )
       - Look for a specific set of Hex bits (NoOP sled)
          - alert tcp any any -> any any (msg:"NoOp sled"; content: "|9090 9090 9090|"; sid:9090; rev: 1; )
       - Incorrect telnet login attempt
          - alert tcp any 23 -> any any (msg:"TELNET login incorrect"; content:"Login incorrect";
            flow:established,from_server; classtype:bad-unknown; sid:2323; rev:6; )
            
    - Demo of SNORT
       - conf file location (/etc/snort/snort.conf)
       - rules location (/etc/snort/rules)
       - running "snort -D -l /var/log/snort -c /etc/snort/snort.conf" tells snort to run in the background 
         and where to store the logs as well as the conf file location
       - running "ps -elf | grep snort" allows you to view where an external system is storing snort.conf and rules
       - two files will be found "alert" and a time stamped pcap to view the alert file you have to use cat for the
         log you have to use tcpdump
         
    - Failed IDS/IPS
       - Fail open
       - Fail close
    - Attacking and evading IDS/IPS
       - Based on delta between devices
          - Insertion attack
             - IDS accepts packet
             - Host will not accept packet
          - Evasion attacking
             - IDS does not accept packet
             - Host will accept packet
    - Technical attacks on IDS/IPS
       - Packet sequence manipulation
       - fragmenting payloaf
       - overlapping fragments with different reassembly by devices
       - Manipulating TCP headers
       - Manipulating IP options
       - Sending data during the TCP connection setup
    - Non-Technical Attacks against IDS/IPS
       - attacking during periods of low manning
         Example - Ramadan 2012 Saudi Aramco Attack
       - attacking during a surge in activity
         Example - Target corps. POS machines
         during the Thanksgiving-Christmas 2013 season
   - Strengthening Defensive Systems
      
